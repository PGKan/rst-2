package org.pgstyle.rst2.random;

import java.nio.ByteBuffer;
import java.util.Random;

import org.pgstyle.rst2.security.RandomInputStream;
import org.pgstyle.rst2.security.Randomiser;
import org.pgstyle.rst2.security.SecureRandomInputStream;

/**
 * <p>
 * The {@code NumberRandomiser} can generate numbers in many different format.
 * </p>
 *
 * @since rst-2
 * @version rst-2.0
 * @author PGKan
 */
public class NumberRandomiser extends Randomiser {

    /**
     * Creates an instance of {@code NumberRandomiser} with a random seed
     * automatically generated by the {@code pglj/rst2} library.
     *
     * @return an instance of {@code NumberRandomiser}
     */
    public static NumberRandomiser getInstance() {
        return NumberRandomiser.getInstance(RandomUtils.randomLongSeed());
    }

    /**
     * Creates an instance of {@code NumberRandomiser} with a given seed.
     *
     * @param seed the seed for the randomiser
     * @return an instance of {@code NumberRandomiser}
     */
    public static NumberRandomiser getInstance(long seed) {
        return new NumberRandomiser(new RandomInputStream(seed));
    }

    /**
     * Creates an instance of {@code NumberRandomiser} with a given seed. The
     * seed will ultimately be casted into {@code long} for seeding the
     * randomiser by using the methods {@link RandomUtils#toLongSeed(String)}.
     *
     * @param seed the seed for the randomiser
     * @return an instance of {@code NumberRandomiser}
     * @throws NullPointerException
     *         if the argument {@code seed} is {@code null}
     */
    public static NumberRandomiser getInstance(String seed) {
        return NumberRandomiser.getInstance(RandomUtils.toLongSeed(seed));
    }

    /**
     * Creates a secured instance of {@code NumberRandomiser} with a random seed
     * automatically generated by the {@code pglj/rst2} library.
     *
     * @return an instance of {@code NumberRandomiser}
     */
    public static NumberRandomiser getInstanceSecure() {
        return NumberRandomiser.getInstanceSecure(RandomUtils.randomBytesSeed());
    }

    /**
     * Creates an instance of {@code NumberRandomiser} with a given seed.
     *
     * @param seed the seed for the randomiser
     * @return an instance of {@code NumberRandomiser}
     * @throws NullPointerException
     *         if the argument {@code seed} is {@code null}
     */
    public static NumberRandomiser getInstanceSecure(byte[] seed) {
        return new NumberRandomiser(new SecureRandomInputStream(seed));
    }

    /**
     * Creates an instance of {@code NumberRandomiser} with a given seed. The
     * seed will ultimately be casted into {@code byte[]} for seeding the
     * randomiser by using the methods {@link RandomUtils#toBytesSeed(long)}.
     *
     * @deprecated This method is marked as deprecated because a long seed could
     *             not utilise the full seeding method of a secured instance of
     *             randomiser. Consider to use
     *             {@link #getInstanceSecure(String)} instead.
     * @param seed the seed for the randomiser
     * @return an instance of {@code NumberRandomiser}
     */
    @Deprecated
    public static NumberRandomiser getInstanceSecure(long seed) {
        return NumberRandomiser.getInstanceSecure(RandomUtils.toBytesSeed(seed));
    }

    /**
     * Creates an instance of {@code NumberRandomiser} with a given seed. The
     * seed will ultimately be casted into {@code byte[]} for seeding the
     * randomiser by using the methods {@link RandomUtils#toBytesSeed(String)}.
     *
     * @param seed the seed for the randomiser
     * @return an instance of {@code NumberRandomiser}
     * @throws NullPointerException
     *         if the argument {@code seed} is {@code null}
     */
    public static NumberRandomiser getInstanceSecure(String seed) {
        return NumberRandomiser.getInstanceSecure(RandomUtils.toBytesSeed(seed));
    }

    /**
     * Initialises the randomiser with a given random input stream.
     *
     * @param randomStream the random stream for generating data
     * @throws NullPointerException
     *         if the argument {@code randomStream} is {@code null}
     */
    public NumberRandomiser(RandomInputStream randomStream) {
        super(randomStream);
    }

    private double gaussian;
    private boolean haveGaussian = false;

    @Override
    public boolean equals(Object object) {
        return super.equals(object);
    }

    @Override
    public int hashCode() {
        return super.hashCode();
    }

    @Override
    public boolean reset() {
        if (this.getRandomStream().resetSupported()) {
            this.haveGaussian = false;
            return super.reset();
        }
        return false;
    }

    /**
     * Generates a random {@code boolean} aka a bit.
     *
     * @return a random {@code true} or {@code false}
     */
    public boolean generateBit() {
        return this.generateByte() < 0;
    }

    /**
     * Generates a random byte.
     *
     * @return a randomly generated {@code byte}
     */
    public byte generateByte() {
        return this.generate(1)[0];
    }

    /**
     * Generates a uniformly distributed random {@code double}. The range of the
     * generated {@code double} is 0 to 1.0.
     *
     * @return a randomly generated {@code double}
     */
    public double generateDouble() {
        return (this.generateLong() >>> 11) / (double) (1l << 53);
    }

    /**
     * Generates a uniformly distributed random {@code float}. The range of the
     * generated {@code float} is 0 to 1.0.
     *
     * @return a randomly generated {@code float}
     */
    public float generateFloat() {
        return (this.generateInteger() >>> 8) / (float) (1 << 24);
    }

    /**
     * Generates a uniformly distributed random {@code int}. The range of the
     * generated integer is -2<sup>31</sup> to 2<sup>31</sup>-1.
     *
     * @return a randomly generated {@code int}
     */
    public int generateInteger() {
        return ByteBuffer.wrap(this.generate(4)).getInt();
    }

    /**
     * Generates a uniformly distributed random {@code long}. The range of the
     * generated integer is -2<sup>63</sup> to 2<sup>63</sup>-1.
     *
     * @return a randomly generated {@code long}
     */
    public long generateLong() {
        return ByteBuffer.wrap(this.generate(8)).getLong();
    }

    /**
     * Generates a uniformly distributed random {@code short}. The range of the
     * generated integer is -2<sup>15</sup> to 2<sup>15</sup>-1.
     *
     * @return a randomly generated {@code short}
     */
    public short generateShort() {
        return ByteBuffer.wrap(this.generate(2)).getShort();
    }

    /**
     * Generates a normally distributed random {@code double}. The range of the
     * generated {@code double} is -1.0 to 1.0.
     *
     * @return a randomly generated {@code double}
     * @see Random#nextGaussian()
     */
    public double generateGaussian() {
        if (haveGaussian) {
            haveGaussian = false;
            return gaussian;
        } else {
            double v1, v2, s;
            do {
                v1 = 2 * this.generateDouble() - 1; // between -1.0 and 1.0
                v2 = 2 * this.generateDouble() - 1; // between -1.0 and 1.0
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s == 0);
            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s) / s);
            gaussian = v2 * multiplier;
            haveGaussian = true;
            return v1 * multiplier;
        }
    }

    @Override
    public String toString() {
        return "rst/NumberRandomiser:" + this.getRandomStream();
    }

}
