package org.pgstyle.rst2.random;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Objects;

/**
 * The {@code RandomUtils} provides utility methods for using randomiser.
 *
 * @since rst-2
 * @version rst-2.0
 * @author PGKan
 */
public final class RandomUtils {

    private static final MessageDigest    HASH;
    private static final NumberRandomiser RNG;

    static {
        // init HASH algorithm
        MessageDigest hash = null;
        String[] algorithms = {"SHA3-512", "SHA-512", "SHA3-256", "SHA-256", "SHA-1"};
        for (int i = 0; Objects.isNull(hash) && i < algorithms.length; i++) {
            try {
                hash = MessageDigest.getInstance(algorithms[i]);
            }
            catch (NoSuchAlgorithmException e) {
                // continue to try next algorithm
            }
        }
        HASH = Objects.requireNonNull(hash, "failed to obtain message digest algorithms");
        // init RNG
        RNG = NumberRandomiser.getInstanceSecure(new SecureRandom().generateSeed(64));
    }

    /**
     * Randomly generates a 64 bits long array of bytes for seeding a
     * randomiser.
     *
     * @return a randomly generated bytes seed
     */
    public static byte[] randomBytesSeed() {
        return RandomUtils.RNG.generate(64);
    }

    /**
     * Randomly generates a long integer for seeding a randomiser.
     *
     * @return a randomly generated long integer seed
     */
    public static long randomLongSeed() {
        return RandomUtils.RNG.generateLong();
    }

    /**
     * Converts a long integer seed into a byte array seed in big endian
     * configuration.
     *
     * @param seed the long integer seed to be converted
     * @return the bytes representation of the long integer seed
     */
    public static byte[] toBytesSeed(long seed) {
        byte[] bytes = new byte[8];
        for (int r = 8 - bytes.length % 8, i = bytes.length; i > 0; i--) {
            bytes[bytes.length - i] = (byte) (seed >>> ((i + r - 1) % 8) * 8 & 0xffl);
        }
        return bytes;
    }

    /**
     * <p>
     * Converts a string seed into a byte array seed using a hashing algorithm.
     * </p>
     * <p>
     * Notice: The choice of the hashing algorithm depends on the platform and
     * version of the Java Rumtime.
     * </p>
     *
     * @param seed the string seed to be converted
     * @return the bytes representation of the string seed
     */
    public static byte[] toBytesSeed(String seed) {
        Objects.requireNonNull(seed, "seed == null");
        byte[] bytes;
        synchronized (RandomUtils.HASH) {
            RandomUtils.HASH.reset();
            bytes = RandomUtils.HASH.digest(seed.getBytes(StandardCharsets.UTF_16BE));
            RandomUtils.HASH.reset();
        }
        return bytes;
    }

    /**
     * Converts a byte array seed into a long integer seed using cycled OR
     * operation in big endian configuration. If the array of bytes exceeds 8
     * bytes in length, information will be lost.
     *
     * @param bytes the byte array seed to be converted
     * @return the long integer seed representation of the byte array seed
     * @throws NullPointerException
     *         if the argument {@code bytes} is {@code null}
     */
    public static long toLongSeed(byte[] bytes) {
        Objects.requireNonNull(bytes, "bytes == null");
        long seed = 0;
        for (int r = 8 - bytes.length % 8, i = bytes.length; i > 0; i--) {
            seed |= (bytes[bytes.length - i] & 0xffl) << (((i + r - 1) % 8) * 8);
        }
        return seed;
    }

    /**
     * <p>
     * Converts a string seed into a long integer seed using a hashing
     * algorithm and cycled OR operation in big endian configuration.
     * </p>
     * <p>
     * Notice: The choice of the hashing algorithm depends on the platform and
     * version of the Java Rumtime.
     * </p>
     *
     * @param seed the string seed to be converted
     * @return the bytes representation of the string seed
     */
    public static long toLongSeed(String seed) {
        return RandomUtils.toLongSeed(RandomUtils.toBytesSeed(seed));
    }

    /** Unnewable @throws UnsupportedOperationException always */
    private RandomUtils() {
        throw new UnsupportedOperationException("unnewable");
    }

}
